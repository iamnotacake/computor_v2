use crate::Expr;

grammar;

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut vec = v;
            vec.push(e);
            vec
        }
    }
};

Semicolon<T>: Vec<T> = {
    <v:(<T> ";")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut vec = v;
            vec.push(e);
            vec
        }
    }
};

// Comma<T>: Vec<T> = {
//     <e:T> <v:("," <T>)*> => match e {
//         None => v,
//         Some(e) => {
//             let mut v = v;
//             v.push(e);
//             v
//         }
//     }
// };

pub AddSub: Expr = {
    <x:AddSub> "+" <y:MulDiv> => Expr::Add(box x, box y),
    <x:AddSub> "-" <y:MulDiv> => Expr::Add(box x, box Expr::Neg(box y)),
    MulDiv,
}

pub MulDiv: Expr = {
    <x:MulDiv> "*" <y:Pow> => Expr::Mul(box x, box y),
    <x:MulDiv> "/" <y:Pow> => Expr::Div(box x, box y),
    <x:MulDiv> "%" <y:Pow> => Expr::Rem(box x, box y),
    <x:MulDiv> "**" <y:Pow> => Expr::MatrixMul(box x, box y),
    Pow,
}

pub Pow: Expr = {
    <x:Pow> "^" <y:Term> => Expr::Pow(box x, box y),
    Term,
}

pub Term: Expr = {
    Real,
    Var,
    Matrix,
    "(" <AddSub> ")",
    Neg,
}

pub Neg: Expr = {
    "-" <x:Term> => Expr::Neg(box x),
}

pub Real: Expr = {
    <x:Number> => Expr::Real(x),
}

pub Var: Expr = {
    <x:r"[a-zA-Z][a-zA-Z0-9]*"> => Expr::Var(x.to_string()),
}

pub Number: f64 = {
    <x:r"-?[0-9]+(\.[0-9]+)?"> => x.parse().unwrap(),
}

MatrixRow: Vec<f64> = {
    "[" <x:Comma<Number>> "]" => x,
}

pub Matrix: Expr = {
	"[" <x:Semicolon<MatrixRow>> "]" => Expr::Matrix(x),
}
